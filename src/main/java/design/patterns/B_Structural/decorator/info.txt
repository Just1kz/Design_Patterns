Шаблон: Декоратор (Decorator) - это структурный паттерн, который позволяет добавлять объектам новые поведения на лету,
помещая их в объекты-обёртки.
=======================================================================================================
Цель:

Динамическое добавление новых обязанностей объекту

=======================================================================================================
Для чего используется:

Используется в качестве альтернативы порождению подклассов для расширения функциональности

Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой
объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым.
Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

=======================================================================================================
Пример использования:

- динамическое и понятное клиентам добавления обязанностей объектам
- реализация обязанностей, которые могут быть сняты с объекта
- расширение класса путем порождения подклассов невозможно по каким либо причинам

--Когда нельзя расширить обязанности объекта с помощью наследования.

Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса.
Расширить такие классы можно только с помощью Декоратора.

=======================================================================================================
Шаги реализации:

- Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.

- Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.

- Создайте класс конкретного компонента и поместите в него основную бизнес-логику.

- Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.

- И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.

- Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.

- Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.
=======================================================================================================
Преимущества и недостатки:
+ Большая гибкость, чем у наследования.
+ Позволяет добавлять обязанности на лету.
+ Можно добавлять несколько новых обязанностей сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

 - Трудно конфигурировать многократно обёрнутые объекты.
 - Обилие крошечных классов.

 =======================================================================================================